local pathToFolder = game.workspace.Mine
local newFolderName = "PartClear"
local objectsToMove = {"Stone", "Copper", "Quartz", "Iron", "Basalt", "Coal", "Quartz", "Iron", "Cobalt", "Granite", "Emerald", "Diorite", "Obsidian", "Ruby", "Mantle", "Nickel", "Magma", "Crystallized Stone", "Ice", "Prismatistone", "Reflectistone", "Bedrock", "Etherstone", "Celestone", "Gold"}

local player = game.Players.LocalPlayer
local newPathToFolder = game.workspace.Mine:FindFirstChild(newFolderName) or Instance.new("Folder")
newPathToFolder.Name = newFolderName
newPathToFolder.Parent = game.workspace.Mine

local function shouldMove(object)
    for _, name in ipairs(objectsToMove) do
        if object.Name == name then
            return true
        end
    end
    return false
end

local isMoving = false
local moveAmount = 10000 -- Số lượng Part di chuyển mỗi lần
local moveDelay = 1 -- Thời gian nghỉ giữa các lần di chuyển (giây)

local function moveParts(partsToMove)
    for _, part in ipairs(partsToMove) do
        part.Parent = newPathToFolder
    end
end

local function movePartsBack(partsToMove)
    for _, part in ipairs(partsToMove) do
        part.Parent = pathToFolder
    end
end

local userInputService = game:GetService("UserInputService")
userInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent then
        if input.KeyCode == Enum.KeyCode.Y then
            isMoving = not isMoving  -- Đảo ngược trạng thái bật/tắt
            if isMoving then
                -- Nếu bật, di chuyển từng loại Part
                for _, name in ipairs(objectsToMove) do
                    local partsToMove = {}
                    local movedParts = 0
                    while movedParts < moveAmount do
                        local child = pathToFolder:FindFirstChild(name)
                        if not child or not child:IsA("Part") then
                            break
                        end
                        table.insert(partsToMove, child)
                        child.Parent = newPathToFolder
                        movedParts = movedParts + 1
                    end
                    wait(moveDelay)
                end
            else
                -- Nếu tắt, di chuyển từng Part từ newPathToFolder về pathToFolder
                for _, name in ipairs(objectsToMove) do
                    local partsToMove = {}
                    local movedParts = 0
                    while movedParts < moveAmount do
                        local child = newPathToFolder:FindFirstChild(name)
                        if not child or not child:IsA("Part") then
                            break
                        end
                        table.insert(partsToMove, child)
                        child.Parent = pathToFolder
                        movedParts = movedParts + 1
                    end
                    wait(moveDelay)
                end
            end
        end
    end
end)
